// Copyright (C) 2016 SRG Technology, LLC
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

using System;
using System.Collections.Generic;
using System.Collections.Specialized;
using HomeSeerAPI;
using HSCF.Communication.Scs.Communication.EndPoints.Tcp;
using HSCF.Communication.ScsServices.Client;

namespace HSPI
{
    /// <summary>
    /// Base class for HSPI plugin.
    /// <para/>
    /// A new class with the name HSPI should be derived from this base class.
    /// <list type="number">
    /// <item><description>The namespace of the new class must be the same as the EXE filename (without extension).</description></item>
    /// <item><description>This new class must be public, named HSPI, and be in the root of the namespace.</description></item>
    /// </list>
    /// <para/>    
    /// Adapted from C# sample generated by Marcus Szolkowski.
    /// See thread "Really simple C# sample plugin available here!" http://board.homeseer.com/showthread.php?t=178122.
    /// </summary>
    /// <seealso cref="HomeSeerAPI.IPlugInAPI" />
    public class HSPIBase2 : HSPIBase
    {
        #region Homeseer interface variables
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// <summary> Homeseer client interface </summary>
        protected IScsServiceClient<IHSApplication> hsClient;
        /// <summary> Homeseer callback client interface - not normally used </summary>
        protected IScsServiceClient<IAppCallbackAPI> callbackClient;
        /// <summary> Homeseer application interface </summary>
        protected HomeSeerAPI.IHSApplication hs;
        /// <summary> Homeseer callback interface </summary>
        protected HomeSeerAPI.IAppCallbackAPI callback;

        /// <summary> Name for this plugin within Homeseer </summary>
        protected string IFACE_NAME = "HspiTemplate";
        /// <summary> Name for the initialization file </summary>
        protected string INI_File = "HspiTemplate.ini";
        /// <summary> Name for this instance.  This plugin does not support multiple instances. </summary>
        protected string INSTANCE_NAME = "";

        /// <summary> Indication of whether to shutdown this plugin </summary>
        internal bool Shutdown = false;
        #endregion

        /// <summary>
        /// Initializes a new instance of the <see cref="HSPIBase2"/> class.
        /// </summary>
        public HSPIBase2()
        {
            // Can't do much here because this class gets loaded and then destroyed by Homeseer during initial discovery & reflection.
            // Instead wait to be initialized during the Connect and InitIO methods, called by the console wrapper and homeseer respectively.
        }

        #region Non plugin methods - Connection to Homeseer
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// <summary>
        /// Connects to Homeseer at the specified server address and port.
        /// This is called by the console wrapper.
        /// </summary>
        /// <param name="serverAddress">The server address.</param>
        /// <param name="serverPort">The server port.</param>
        /// <exception cref="Exception"> Error connecting homeseer SCS client </exception>
        /// <exception cref="Exception"> Error connecting callback SCS client </exception>
        /// <exception cref="Exception"> Error connecting homeseer to our plugin </exception>
        public virtual void Connect(string serverAddress, int serverPort)
        {
            // Create our main connection to the homeseer TCP communication framework
            // part 1 - hs object Proxy
            try
            {
                hsClient = ScsServiceClientBuilder.CreateClient<IHSApplication>(new ScsTcpEndPoint(serverAddress, serverPort), this);
                hsClient.Connect();
                hs = hsClient.ServiceProxy;
                double APIVersion = hs.APIVersion;          // just to make sure our connection is valid
            }
            catch (Exception ex)
            {
                throw new Exception("Error connecting homeseer SCS client: " + ex.Message, ex);
            }

            // part 2 - callback object Proxy
            try
            {
                callbackClient = ScsServiceClientBuilder.CreateClient<IAppCallbackAPI>(new ScsTcpEndPoint(serverAddress, serverPort), this);
                callbackClient.Connect();
                callback = callbackClient.ServiceProxy;
                double APIVersion = callback.APIVersion;    // just to make sure our connection is valid
            }
            catch (Exception ex)
            {
                throw new Exception("Error connecting callback SCS client: " + ex.Message, ex);
            }

            // Establish the reverse connection from homeseer back to our plugin
            try
            {
                hs.Connect(IFACE_NAME, INSTANCE_NAME);
            }
            catch (Exception ex)
            {
                throw new Exception("Error connecting homeseer to our plugin: " + ex.Message, ex);
            }

        }

        /// <summary>
        /// Test our SCS client connection: <see cref="HSPI"/> is connected.
        /// The console wrapper will call this periodically to check if there is a problem.
        /// </summary>
        /// <value><c>true</c> if connected; otherwise, <c>false</c>.</value>
        public virtual bool Connected
        {
            get
            {
                return hsClient.CommunicationState == HSCF.Communication.Scs.Communication.CommunicationStates.Connected;
            }
        }
        #endregion

        #region Required Plugin Methods - Information & Initialisation
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// <summary> Get the name of this plugin </summary>
        public virtual string Name
        {
            get { return IFACE_NAME; }
        }

        /// <summary>
        /// Get the instance name of this plugin.  Only valid if SupportsMultipleInstances is true.
        /// Multiple instance are not supported by this plugin.
        /// </summary>
        /// <returns>System.String</returns>
        public virtual string InstanceFriendlyName()
        {
            return INSTANCE_NAME;
        }

        /// <summary>
        /// HomeSeer may call this function at any time to get the status of the plug-in. 
        /// Normally the status is displayed on the Interfaces page. 
        /// intStatus field: OK, INFO, WARNING, CRITICAL, FATAL.
        /// sStatus field: string.
        /// </summary>
        /// <returns>IPlugInAPI.strInterfaceStatus
        /// </returns>
        /// 
        public virtual IPlugInAPI.strInterfaceStatus InterfaceStatus()
        {
            IPlugInAPI.strInterfaceStatus s = new IPlugInAPI.strInterfaceStatus();
            s.intStatus = IPlugInAPI.enumInterfaceStatus.OK;
            return s;
        }

        /// <summary>
        /// API's that this plugin supports.  
        /// This is a bit field.
        /// All plugins must set CA_IO for I/O support.
        /// Other values: CA_Security, CA_Thermostat, CA_Music, CA_SourceSwitch.
        /// </summary>
        /// <returns>System.Int32</returns>
        public virtual int Capabilities()
        {
            return (int)HomeSeerAPI.Enums.eCapabilities.CA_IO;
        }

        /// <summary>
        /// Plugin licensing mode: 
        /// 1 = plugin is not licensed, 
        /// 2 = plugin is licensed and user must purchase a license but there is a 30-day trial.
        /// </summary>
        /// <returns>System.Int32</returns>
        public virtual int AccessLevel()
        {
            return 1;
        }

        /// <summary> Indicate if Homeseer should manage a COM port for the plugin. </summary>
        /// <value><c>true</c> if COM port required; otherwise, <c>false</c>.</value>
        public virtual bool HSCOMPort
        {
            get { return false; }
        }

        /// <summary>
        /// Indicate if the plugin supports the ability to add devices through the Add Device link on the device utility page.
        /// If <c>true</c>, a tab appears on the add device page that allows the user to configure specific options for the new device.
        /// </summary>
        public virtual bool SupportsAddDevice()
        {
            return false;
        }

        /// <summary>
        /// Indicate if the plugin allows for configuration of the devices via the device utility page.
        /// This will allow you to generate some HTML controls that will be displayed to the user for modifying the device.
        /// </summary>
        public virtual bool SupportsConfigDevice()
        {
            return false;
        }

        /// <summary> Indicate if the plugin manages all devices in the system. </summary>
        public virtual bool SupportsConfigDeviceAll()
        {
            return false;
        }

        /// <summary>
        /// Indicate if the plugin supports multiple instances.  
        /// The plugin may be launched multiple times and will be passed a unique instance name as a command line parameter to the Main function.
        /// </summary>
        public virtual bool SupportsMultipleInstances()
        {
            return false;
        }

        /// <summary> Indicate if plugin supports multiple instances using a single executable.</summary>
        public virtual bool SupportsMultipleInstancesSingleEXE()
        {
            return false;
        }

        /// <summary>
        /// HSTouch uses the Generic Event callback in some music plug-ins so that it can be notified of when a song changes, 
        /// rather than having to repeatedly query the music plug-in for the current song status.  
        /// If this property is present (and returns True), especially in a Music plug-in, 
        /// then HSTouch (and other plug-ins) will know that your HSEvent procedure can handle generic callbacks.  
        /// </summary>
        public virtual bool RaisesGenericCallbacks()
        {
            return false;
        }

        /// <summary>
        /// When you wish to have HomeSeer call back in to your plug-in or application when certain events happen in the system,
        /// call the RegisterEventCB procedure and provide it with event you wish to monitor. 
        /// See RegisterEventCB for more information and an example and event types.
        /// </summary>
        public virtual void HSEvent(Enums.HSEvent EventType, object[] parameters)
        {
        }

        /// <summary>
        /// Initialize the plugin and associated hardware/software, start any threads
        /// </summary>
        /// <param name="port">The COM port for the plugin if required.</param>
        /// <returns>Warning message or empty for success.</returns>
        public virtual string InitIO(string port)
        {
            return "";
        }

        /// <summary>
        /// If a device is owned by your plug-in (interface property set to the name of the plug-in) and the device's status_support property is set to True, 
        /// then this procedure will be called in your plug-in when the device's status is being polled, such as when the user clicks "Poll Devices" on the device status page.
        /// Normally your plugin will automatically keep the status of its devices updated.
        /// There may be situations where automatically updating devices is not possible or CPU intensive.
        /// In these cases the plug-in may not keep the devices updated. HomeSeer may then call this function to force an update of a specific device.
        /// This request is normally done when a user displays the status page, or a script runs and needs to be sure it has the latest status.
        /// </summary>
        /// <param name="dvref">Reference Id for the device</param>
        /// <returns>IPlugInAPI.PollResultInfo</returns>
        public virtual IPlugInAPI.PollResultInfo PollDevice(int dvref)
        {
            IPlugInAPI.PollResultInfo pollResult = new IPlugInAPI.PollResultInfo();
            pollResult.Result = IPlugInAPI.enumPollResult.Device_Not_Found;
            pollResult.Value = 0;

            return pollResult;
        }

        /// <summary>
        /// SetIOMulti is called by HomeSeer when a device that your plugin owns is controlled.  
        /// Your plugin owns a device when it's INTERFACE property is set to the name of your plugin.
        /// </summary>
        /// <param name="colSend">
        /// This is a collection of CAPIControl objects, one object for each device that needs to be controlled. 
        /// Look at the ControlValue property to get the value that device needs to be set to.
        /// </param>
        public virtual void SetIOMulti(List<CAPI.CAPIControl> colSend)
        {
            // homeseer will inform us when the one of our devices has changed.  Push that change through to the field.
        }

        /// <summary>
        /// Called when HomeSeer is not longer using the plugin. 
        /// This call will be made if a user disables a plugin from the interfaces configuration page and when HomeSeer is shut down.
        /// </summary>
        public virtual void ShutdownIO()
        {
            // let our console wrapper know we are finished
            Shutdown = true;
        }
        #endregion

        #region Required Plugin Methods - Actions, Triggers & Conditions
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// <summary>
        /// Called in your plugin by HomeSeer whenever the user uses the search function of HomeSeer, and your plugin is loaded and initialized.  
        /// Unlike ActionReferencesDevice and TriggerReferencesDevice, this search is not being specific to a device, 
        /// it is meant to find a match anywhere in the resources managed by your plugin.  
        /// This could include any textual field or object name that is utilized by the plugin.
        /// </summary>
        /// <param name="SearchString">The search string.</param>
        /// <param name="RegEx">if set to <c>true</c> then the search string is a regular expression.</param>
        /// <returns>Array of SearchReturn items describing what was found and where it was found.</returns>
        public virtual SearchReturn[] Search(string SearchString, bool RegEx)
        {
            return null;
        }

        /// <summary>
        /// The HomeSeer events page has an option to set the editing mode to "Advanced Mode". 
        /// This is typically used to enable options that may only be of interest to advanced users or programmers. 
        /// The Set in this function is called when advanced mode is enabled. 
        /// Your plugin can also enable this mode if an advanced selection was saved and needs to be displayed.
        /// </summary>
        public virtual bool ActionAdvancedMode
        {
            get { return false; }
            set { /* do nothing */ }
        }

        /// <summary> Indicate if the plugin has any triggers. </summary>
        public virtual bool HasTriggers
        {
            get { return false; }
        }

        /// <summary> Number of triggers the plugin supports. </summary>
        public virtual int TriggerCount
        {
            get { return 0; }
        }

        /// <summary>
        /// This function is called from the HomeSeer event page when an event is in edit mode. 
        /// Your plugin needs to return HTML controls so the user can make action selections. 
        /// Normally this is one of the HomeSeer jquery controls such as a clsJquery.jqueryCheckbox.
        /// </summary>
        /// <param name="sUnique">A unique string that can be used with your HTML controls to identify the control. All controls need to have a unique ID.</param>
        /// <param name="ActInfo">Object that contains information about the action like current selections.</param>
        /// <returns>HTML controls that need to be displayed so the user can select the action parameters.</returns>
        public virtual string ActionBuildUI(string sUnique, IPlugInAPI.strTrigActInfo ActInfo)
        {
            return "";
        }

        /// <summary>
        /// Return TRUE if the given action is configured properly. 
        /// There may be times when a user can select invalid selections for the action and in this case you would return FALSE so HomeSeer will not allow the action to be saved.
        /// </summary>
        /// <param name="ActInfo">Object describing the action.</param>
        public virtual bool ActionConfigured(IPlugInAPI.strTrigActInfo ActInfo)
        {
            return true;
        }

        /// <summary> The number of actions the plugin supports. </summary>
        public virtual int ActionCount()
        {
            return 0;
        }

        public virtual string ActionFormatUI(IPlugInAPI.strTrigActInfo ActInfo)
        {
            return "";
        }

        /// <summary>
        /// When a user edits your event actions in the HomeSeer events, this function is called to process the selections.
        /// </summary>
        /// <param name="PostData">A collection of name value pairs that include the user's selections.</param>
        /// <param name="TrigInfoIN">Object that contains information about the action.</param>
        /// <returns>Object that holds the parsed information for the action. HomeSeer will save this information for you in the database.</returns>
        public virtual IPlugInAPI.strMultiReturn ActionProcessPostUI(NameValueCollection PostData, IPlugInAPI.strTrigActInfo TrigInfoIN)
        {
            return new IPlugInAPI.strMultiReturn();
        }

        /// <summary> Indicate if the given devices is referenced by the given action. </summary>
        public virtual bool ActionReferencesDevice(IPlugInAPI.strTrigActInfo ActInfo, int dvRef)
        {
            return false;
        }

        /// <summary>
        /// Return the name of the action given an action number. The name of the action will be displayed in the HomeSeer events actions list.
        /// </summary>
        /// <param name="ActionNumber">The number of the action. Each action is numbered, starting at 1.</param>
        /// <returns>Name of the action.</returns>
        public virtual string get_ActionName(int ActionNumber)
        {
            return "";
        }

        /// <summary>
        /// Set to <c>true</c> if the trigger is being used as a CONDITION.  
        /// Check this value in BuildUI and other procedures to change how the trigger is rendered if it is being used as a condition or a trigger.
        /// </summary>
        public virtual bool get_Condition(IPlugInAPI.strTrigActInfo TrigInfo)
        {
            return false;
        }

        public virtual void set_Condition(IPlugInAPI.strTrigActInfo TrigInfo, bool Value)
        {
        }

        /// <summary> Indicate if the given trigger can also be used as a condition for the given grigger number. </summary>
        public virtual bool get_HasConditions(int TriggerNumber)
        {
            return false;
        }

        /// <summary> Return the HTML controls for a given trigger. </summary>
        public virtual string TriggerBuildUI(string sUnique, IPlugInAPI.strTrigActInfo TrigInfo)
        {
            return "";
        }

        /// <summary> After the trigger has been configured, this function is called in your plugin to display the configured trigger. </summary>
        /// <returns>Text that describes the given trigger.</returns>
        public virtual string TriggerFormatUI(IPlugInAPI.strTrigActInfo TrigInfo)
        {
            return "";
        }

        /// <summary>
        /// Process a post from the events web page when a user modifies any of the controls related to a plugin trigger. 
        /// After processing the user selctions, create and return a strMultiReturn object.
        /// </summary>
        public virtual IPlugInAPI.strMultiReturn TriggerProcessPostUI(NameValueCollection PostData, IPlugInAPI.strTrigActInfo TrigInfoIN)
        {
            return new IPlugInAPI.strMultiReturn();
        }

        /// <summary> Indicate if the given device is referenced by the given trigger. </summary>
        public virtual bool TriggerReferencesDevice(IPlugInAPI.strTrigActInfo TrigInfo, int dvRef)
        {
            return false;
        }

        /// <summary>
        /// Although this appears as a function that would be called to determine if a trigger is true or not, it is not.  
        /// Triggers notify HomeSeer of trigger states using TriggerFire , but Triggers can also be conditions, and that is where this is used.  
        /// If this function is called, TrigInfo will contain the trigger information pertaining to a trigger used as a condition.  
        /// When a user's event is triggered and it has conditions, the conditions need to be evaluated immediately, 
        /// so there is not regularity with which this function may be called in your plugin.  
        /// It may be called as often as once per second or as infrequently as once in a blue moon.
        /// </summary>
        public virtual bool TriggerTrue(IPlugInAPI.strTrigActInfo TrigInfo)
        {
            return false;
        }

        /// <summary> Return the number of sub triggers your plugin supports. </summary>
        public virtual int get_SubTriggerCount(int TriggerNumber)
        {
            return 0;
        }

        /// <summary> Return the text name of the sub trigger given its trugger number and sub trigger number. </summary>
        public virtual string get_SubTriggerName(int TriggerNumber, int SubTriggerNumber)
        {
            return "";
        }

        /// <summary> Indicate if the given trigger is configured properly. </summary>
        public virtual bool get_TriggerConfigured(IPlugInAPI.strTrigActInfo TrigInfo)
        {
            return true;
        }

        /// <summary> Return the name of the given trigger based on the trigger number. </summary>
        public virtual string get_TriggerName(int TriggerNumber)
        {
            return "";
        }

        /// <summary>
        /// When an event is triggered, this function is called to carry out the selected action. 
        /// Use the ActInfo parameter to determine what action needs to be executed then execute this action.
        /// </summary>
        public virtual bool HandleAction(IPlugInAPI.strTrigActInfo ActInfo)
        {
            return false;
        }

        /// <summary>
        /// If your plugin is registered as a Speak proxy plugin, then when HomeSeer is asked to speak something, 
        /// it will pass the speak information to your plugin using this procedure.  
        /// When your plugin is ready to do the actual speaking, it should call SpeakProxy, 
        /// and pass the information that it got from this procedure to SpeakProxy.  
        /// It may be necessary or a feature of your plugin to modify the text being spoken or the host/instance list provided in the host parameter - this is acceptable.
        /// </summary>
        /// <param name="device">This is the device that is to be used for the speaking.</param>
        /// <param name="text">This is the text to be spoken, or if it is a WAV file to be played, then the characters ":\" will be found starting at position 2 of the string as playing a WAV file with the speak command in HomeSeer REQUIRES a fully qualified path and filename of the WAV file to play.</param>
        /// <param name="wait">This parameter tells HomeSeer whether to continue processing commands immediately or to wait until the speak command is finished - pass this parameter unchanged to SpeakProxy.</param>
        /// <param name="host">This is a list of host:instances to speak or play the WAV file on.  An empty string or a single asterisk (*) indicates all connected speaker clients on all hosts.  Normally this parameter is passed to SpeakProxy unchanged.</param>
        public virtual void SpeakIn(int device, string text, bool wait, string host)
        {
        }
        #endregion

        #region Required Plugin Methods - Web Interface
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// <summary>
        /// This function is available for the ease of converting older HS2 plugins, however, it is desirable to use the new clsPageBuilder class for all new development.
        /// This function is called by HomeSeer from the form or class object that a web page was registered with using RegisterConfigLink.  
        /// You must have a GenPage procedure per web page that you register with HomeSeer.  
        /// This page is called when the user requests the web page with an HTTP Get command, which is the default operation when the browser requests a page.
        /// </summary>
        public virtual string GenPage(string link)
        {
            return "";
        }

        /// <summary>
        /// When your plugin web page has form elements on it, and the form is submitted, this procedure is called to handle the HTTP "Put" request.  
        /// There must be one PagePut procedure in each plugin object or class that is registered as a web page in HomeSeer.
        /// </summary>
        public virtual string PagePut(string data)
        {
            return "";
        }

        /// <summary>
        /// A complete page needs to be created and returned.
        /// Web pages that use the clsPageBuilder class and registered with hs.RegisterLink and hs.RegisterConfigLink will then be called through this function. 
        /// </summary>
        /// <param name="page">The name of the page as passed to the hs.RegisterLink function.</param>
        /// <param name="user">The name of logged in user.</param>
        /// <param name="userRights">The rights of the logged in user.</param>
        /// <param name="queryString">The query string.</param>
        public virtual string GetPagePlugin(string page, string user, int userRights, string queryString)
        {
            return "";
        }

        /// <summary>
        /// When a user clicks on any controls on one of your web pages, this function is then called with the post data. You can then parse the data and process as needed.
        /// </summary>
        /// <param name="page">The name of the page as passed to the hs.RegisterLink function.</param>
        /// <param name="data">The post data.</param>
        /// <param name="user">The name of logged in user.</param>
        /// <param name="userRights">The rights of the logged in user.</param>
        /// <returns>Any serialized data that needs to be passed back to the web page, generated by the clsPageBuilder class.</returns>
        public virtual string PostBackProc(string page, string data, string user, int userRights)
        {
            return "";
        }

        /// <summary>
        /// If SupportsConfigDevice returns <c>true</c>, this function will be called when the device properties are displayed for your device. 
        /// The device properties is displayed from the Device Utility page. 
        /// This page displays a tab for each plugin that controls the device. 
        /// Normally, only one plugin will be associated with a single device. 
        /// If there is any configuration that needs to be set on the device, you can return any HTML that you would like displayed. 
        /// Normally this would be any jquery controls that allow customization of the device. 
        /// The returned HTML is just an HTML fragment and not a complete page.
        /// </summary>
        /// <param name="ref">The device reference id.</param>
        /// <param name="user">The name of logged in user.</param>
        /// <param name="userRights">The rights of the logged in user.</param>
        /// <param name="newDevice"><c>True</c> if this is a new device being created for the first time. 
        /// In this case, the device configuration dialog may present different information than when simply editing an existing device.</param>
        /// <returns>A string containing HTML to be displayed. Return an empty string if there is not configuration needed.</returns>
        public virtual string ConfigDevice(int @ref, string user, int userRights, bool newDevice)
        {
            return "";
        }

        /// <summary>
        /// This function is called when a user posts information from your plugin tab on the device utility page. 
        /// </summary>
        /// <param name="ref">The device reference id.</param>
        /// <param name="data">The post data.</param>
        /// <param name="user">The name of logged in user.</param>
        /// <param name="userRights">The rights of the logged in user.</param>
        /// <returns>Enums.ConfigDevicePostReturn.</returns>
        public virtual Enums.ConfigDevicePostReturn ConfigDevicePost(int @ref, string data, string user, int userRights)
        {
            return Enums.ConfigDevicePostReturn.DoneAndCancel;
        }
        #endregion

        #region Required Plugin Methods - User defined functions
        ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        /// <summary> Call a function in the plugin. </summary>
        /// <param name="functionName">The name of the function to call.</param>
        /// <param name="parms">An array of parameters to pass to the function.</param>
        public virtual object PluginFunction(string functionName, object[] parms)
        {
            return null;
        }

        /// <summary> Get a property from the plugin. </summary>
        /// <param name="propertyName">The name of the property to access.</param>
        /// <param name="parms">An array of parameters to pass to the function.</param>
        public virtual object PluginPropertyGet(string propertyName, object[] parms)
        {
            return null;
        }

        /// <summary> Set a property of the plugin. </summary>
        /// <param name="propertyName">The name of the property to access.</param>
        /// <param name="value">The value to set the property.</param>
        public virtual void PluginPropertySet(string propertyName, object value)
        {
        }
        #endregion

        #region Support functions
        /// <summary>
        /// Sets the device value.
        /// </summary>
        /// <param name="refId">The device reference identifier.</param>
        /// <param name="value">The value/status of the device.</param>
        /// <param name="trigger">if set to <c>true</c> process triggers normally, otherwise only change the value.</param>
        public virtual void SetDeviceValue(int refId, double value, bool trigger = true)
        {
            hs.SetDeviceValueByRef(refId, value, trigger);
        }
        #endregion
    }
}